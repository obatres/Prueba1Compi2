package analizadores; 
import arbol.Expresion;
import arbol.Nodo;
import arbol.Instruccion;
import arbol.Asignacion;
import arbol.Simbolo.*;
import arbol.TablaDeSimbolos;
import java.util.LinkedList;
import arbol.Operacion;
import arbol.Imprimir;
import arbol.If.If;
import arbol.If.IfElse;
import arbol.While.While;
import arbol.DoWhile.DoWhile;
import arbol.SwitchCase.NodoCase;
import arbol.SwitchCase.SwitchCase;
import arbol.SwitchCase.Break;
import arbol.Tipo.tipo.*;
import arbol.Tipo;
import arbol.Declaracion;
import arbol.Single;
import arbol.id;
import java_cup.runtime.*;

parser code 
{:
    public LinkedList<Nodo> AST;
    /**
     * Método al que se llama automáticamente ante algún error sintactico.
     **/ 
    public void syntax_error(Symbol s){ 
        System.out.println("Error Sintáctico en la Línea " + (s.left) +
        " Columna "+s.right+ ". No se esperaba este componente: " +s.value+"."); 
    } 

    /**
     * Método al que se llama automáticamente ante algún error sintáctico 
     * en el que ya no es posible una recuperación de errores.
     **/ 
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{ 
        System.out.println("Error síntactico irrecuperable en la Línea " + 
        (s.left)+ " Columna "+s.right+". Componente " + s.value + 
        " no reconocido."); 
    }  
    public LinkedList<Nodo> getAST() {
        return AST;
    }
:} 

terminal String PTCOMA,PARIZQ,PARDER,CORIZQ,CORDER,LLAVEIZQ, LLAVEDER;
terminal String POTENCIA, MODULO;
terminal String MAS,MENOS,POR,DIVIDIDO;
terminal String IGUALD, MAYOR,MENOR, MAYORIGUAL, MENORIGUAL, DESIGUAL;
terminal String SWITCH, CASE, BREAK,DEFAULT;
terminal String AND,OR,NOT;
terminal String INTERROGACION, DOSP;
terminal String IF, TRUE, FALSE,ELSE; 
terminal String WHILE, DO;
terminal String ENTERO;
terminal String DECIMAL;
terminal String CADENA;
terminal String UMENOS;
terminal String REVALUAR;
terminal String RDECLARA;
terminal String IDENTIFICADOR;
terminal String IGUAL, ENTEROT, CADENAT;
terminal String PRINT;
terminal String C, COMA;

non terminal ini;
non terminal LinkedList<Nodo> instrucciones;
non terminal Nodo instruccion;
non terminal Nodo expresion;
non terminal Nodo expresioncomp;
non terminal LinkedList<NodoCase> listacase;
non terminal NodoCase CASES;
non terminal Tipo tipovar;
non terminal listaDeclaraciones, ListaExp;





precedence left MAS,MENOS;
precedence left POR,DIVIDIDO, MODULO;
precedence left POTENCIA;
precedence left AND, OR;
precedence left IGUALD, DESIGUAL;
precedence left MAYOR,MENOR, MAYORIGUAL, MENORIGUAL;
precedence right UMENOS, NOT; 

start with ini; 

ini::=instrucciones:a
    {:
    parser.AST=a;
    :};

instrucciones ::= 
   instrucciones:a instruccion:b 
    {:
    RESULT= a;
    RESULT.add(b);
    :}
 | instruccion:a 
    {:
    RESULT= new LinkedList<>();
    RESULT.add(a);
    :}; 

instruccion ::= 
    PRINT PARIZQ expresion:a PARDER PTCOMA
        {:
            //System.out.println("El valor de la expresión es: "+a);
            RESULT  =  new Imprimir ((Expresion)a);
        :}


    | IDENTIFICADOR:a IGUAL expresion:b 
        {:
            RESULT = new Declaracion (a, (Expresion)b,1);       
        :}


    | IDENTIFICADOR:a IGUAL expresion:b PTCOMA 
        {:
            RESULT = new Declaracion(a,(Expresion)b,1);
        :}

    | IDENTIFICADOR:a IGUAL listaDeclaraciones

    
    | expresioncomp:a
        {:
            RESULT  =  new Imprimir ((Expresion)a);
        :}


    | RDECLARA expresioncomp:a INTERROGACION expresion:b DOSP expresion:c 
        {:
            RESULT=new Imprimir((Expresion)new Operacion(Operacion.Tipo_operacion.TERNARIO,(Expresion)a, (Expresion)b,(Expresion)c)); 
        :}


    | IF PARIZQ expresioncomp:a PARDER LLAVEIZQ instrucciones:b LLAVEDER  
        {:
            RESULT= new If((Operacion)a,b);
        :}


    | IF PARIZQ expresioncomp:a PARDER LLAVEIZQ instrucciones:b LLAVEDER ELSE LLAVEIZQ instrucciones:c LLAVEDER
        {:
            RESULT= new If((Operacion)a,b,c);
        :}


    | IF PARIZQ expresioncomp:a PARDER LLAVEIZQ instrucciones:b LLAVEDER ELSE IF PARIZQ expresioncomp:d PARDER LLAVEIZQ instrucciones:c LLAVEDER
        {:
            RESULT= new IfElse((Operacion)a,(Operacion)d,b,c);
        :}


    | SWITCH:s PARIZQ expresion:a PARDER LLAVEIZQ listacase:b LLAVEDER    
        {:
            RESULT= new SwitchCase(b,(Expresion)a);
        :}
    | BREAK:a PTCOMA
        {:
            RESULT= new Break (a);
        :}
    | WHILE:s PARIZQ expresioncomp:a PARDER LLAVEIZQ instrucciones:b LLAVEDER
        {:
            //System.out.println(s);
            RESULT = new While((Expresion)a, b);
        :}
    | DO:s LLAVEIZQ instrucciones:b LLAVEDER WHILE PARIZQ expresioncomp:a PARDER PTCOMA 
        {:
            //System.out.println(s);
            RESULT = new DoWhile((Expresion)a,b);
        :}
;   


listacase::= listacase:a CASES:b
                {:  
                    RESULT=a;
                    RESULT.add(b);
                :}
            |CASES:a
                {:
                    RESULT=new LinkedList<>();
                    RESULT.add(a);
                :}
;
            
CASES::= CASE expresion:a DOSP instrucciones:b 
            {:
                RESULT= new NodoCase((Expresion)a,b);
            :}
        |DEFAULT DOSP instrucciones:a
            {:
                RESULT= new NodoCase(a);
            :}
;




listaDeclaraciones::= C  ListaExp PARDER
    
;

ListaExp ::= ListaExp COMA expresion 

            |expresion
;

expresion  ::= 
        MENOS expresion:a                      {:RESULT=new Operacion(Operacion.Tipo_operacion.UMENOS,(Expresion)a);:}%prec UMENOS     
    |   expresion:a MAS        expresion:b     {:RESULT=new Operacion(Operacion.Tipo_operacion.SUMA,(Expresion)a,(Expresion)b);:}
    |   expresion:a MENOS      expresion:b     {:RESULT=new Operacion(Operacion.Tipo_operacion.RESTA,(Expresion)a,(Expresion)b);:}
    |   expresion:a POR        expresion:b     {:RESULT=new Operacion(Operacion.Tipo_operacion.MULTIPLICACION,(Expresion)a,(Expresion)b);:}
    |   expresion:a DIVIDIDO   expresion:b     {:RESULT=new Operacion(Operacion.Tipo_operacion.DIVISION,(Expresion)a,(Expresion)b);:}
    |   expresion:a POTENCIA   expresion:b     {:RESULT=new Operacion(Operacion.Tipo_operacion.POTENCIA,(Expresion)a,(Expresion)b);:}
    |   expresion:a MODULO     expresion:b     {:RESULT=new Operacion(Operacion.Tipo_operacion.MODULO,(Expresion)a,(Expresion)b);:}
    |   ENTERO:a                               {:RESULT=new Single(a,new Tipo(Tipo.tipo.INT));:}
    |   DECIMAL:a                              {:RESULT=new Single(a,new Tipo(Tipo.tipo.DOUBLE));:}
    |   CADENA:a                               {:RESULT=new Single(a,new Tipo(Tipo.tipo.STRING));:} 
    |   TRUE:a                                 {:RESULT=new Single(a,new Tipo(Tipo.tipo.BOOLEAN));:}
    |   FALSE:a                                {:RESULT=new Single(a,new Tipo(Tipo.tipo.BOOLEAN));:}
    |   IDENTIFICADOR:a                        {:RESULT=new id(a);:}
    |   PARIZQ expresion:a PARDER              {:RESULT=a;:}
;


expresioncomp::=
        expresion:a IGUALD          expresion:b     {:RESULT=new Operacion(Operacion.Tipo_operacion.IGUALIGUAL,(Expresion)a,(Expresion)b);:}
    |   expresion:a DESIGUAL        expresion:b     {:RESULT=new Operacion(Operacion.Tipo_operacion.DESIGUAL,(Expresion)a,(Expresion)b);:}
    |   expresion:a MAYOR           expresion:b     {:RESULT=new Operacion(Operacion.Tipo_operacion.MAYOR,(Expresion)a,(Expresion)b);:}
    |   expresion:a MENOR           expresion:b     {:RESULT=new Operacion(Operacion.Tipo_operacion.MENOR,(Expresion)a,(Expresion)b);:}
    |   expresion:a MAYORIGUAL      expresion:b     {:RESULT=new Operacion(Operacion.Tipo_operacion.MAYORIGUAL,(Expresion)a,(Expresion)b);:}
    |   expresion:a MENORIGUAL      expresion:b     {:RESULT=new Operacion(Operacion.Tipo_operacion.MENORIGUAL,(Expresion)a,(Expresion)b);:}
    |   expresioncomp:a AND         expresioncomp:b     {:RESULT=new Operacion(Operacion.Tipo_operacion.AND,(Expresion)a,(Expresion)b);:}
    |   expresioncomp:a OR          expresioncomp:b     {:RESULT=new Operacion(Operacion.Tipo_operacion.OR,(Expresion)a,(Expresion)b);:}
    |                   NOT         expresioncomp:a     {:RESULT=new Operacion(Operacion.Tipo_operacion.NOT,(Expresion)a);:}
;

  
